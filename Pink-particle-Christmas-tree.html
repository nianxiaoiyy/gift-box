<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Merry Christmas! </title>
    <style>
        /* 基础样式设置 */
        body {
            margin: 0;
            background: radial-gradient(circle at center, #110511 0%, #000000 100%); /* 深紫红黑背景渐变 */
            overflow: hidden; /* 隐藏滚动条 */
            font-family: sans-serif;
            touch-action: none; /* 禁用默认触控行为 */
        }

        canvas {
            display: block; /* 块级显示 */
        }

        /* UI覆盖层 - 用于显示文字提示 */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 允许点击穿透到canvas */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10; /* 确保在canvas上方 */
        }

        /* 标题样式 */
        .title {
            position: absolute;
            top: 15%;
            color: #fff;
            font-family: 'Brush Script MT', cursive; /* 手写字体 */
            font-size: 4.5rem;
            text-shadow: 0 0 10px #ffc0cb, 0 0 30px #ff69b4; /* 粉色光晕效果 */
            opacity: 0;
            animation: softIn 3s ease-out forwards; /* 淡入动画 */
        }

        /* 操作提示 */
        .tips {
            position: absolute;
            bottom: 30px;
            color: rgba(255, 255, 255, 0.4); /* 半透明白色 */
            font-size: 0.8rem;
            letter-spacing: 2px; /* 字母间距 */
        }

        /* 淡入动画关键帧 */
        @keyframes softIn {
            0% { opacity: 0; transform: scale(0.95) translateY(-20px); } /* 初始状态：透明、缩小、上移 */
            100% { opacity: 1; transform: scale(1) translateY(0); } /* 最终状态：显示、正常大小、归位 */
        }
    </style>
</head>
<body>

    <!-- UI覆盖层 -->
    <div class="ui-overlay">
        <div class="title">Merry Christmas!</div>
        <div class="tips">DRAG TO ROTATE</div> <!-- 拖拽旋转提示 -->
    </div>

    <!-- 主画布 -->
    <canvas id="c"></canvas>

    <script>
        // 获取canvas和2D上下文
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');

        // 变量声明
        let width, height; // 画布尺寸
        let particles = []; // 粒子数组
    
        // --- 核心配置 ---
        const CONFIG = {
            snowCount: 3500,        // 雪花数量（密集）
            snowRange: 3500,         // 雪花分布范围
            treeLayers: 9,          // 圣诞树层级数
            layerDensity: 40,       // 每层粒子密度
            fillParticles: 4500,    // 内部填充粒子数（保证树体饱满）
            baseDist: 900           // 基础距离（用于透视计算）
        };

        // 颜色池 - 定义各种颜色组合
        const COLORS = {
            treeWhite: '255, 255, 255',     // 纯白色
            treePale: '255, 220, 230',      // 浅粉色
            treePink: '255, 105, 180',      // 粉红色
            treeDeep: '220, 20, 80',        // 深红色
            snowGold: '255, 215, 0'         // 金色（雪花用）
        };

        // 程序状态管理
        let state = {
            rotX: -0.3,     // X轴旋转角度（俯视角）
            rotY: 0,        // Y轴旋转角度
            zoom: 1.0,      // 缩放比例
            autoRot: 0,     // 自动旋转角度
            time: 0         // 时间计数器
        };

        // -----------------------
        // 粒子类定义
        // -----------------------
        class Particle {
            constructor(opt) {
                this.type = opt.type;       // 粒子类型（snow, inner, branch等）
                this.ox = opt.x || 0;       // 原始X坐标
                this.oy = opt.y || 0;       // 原始Y坐标
                this.oz = opt.z || 0;       // 原始Z坐标
                
                this.sizeBase = opt.size || 1;      // 基础尺寸
                this.alphaBase = opt.alpha || 1;    // 基础透明度
                this.color = opt.color || COLORS.treeWhite; // 颜色

                this.phase = Math.random() * Math.PI * 2; // 相位（用于动画）
                
                // 雪花粒子特殊初始化
                if (this.type === 'snow') {
                    // 随机分布在空间范围内
                    this.ox = (Math.random()-0.5) * CONFIG.snowRange;
                    this.oy = (Math.random()-0.5) * CONFIG.snowRange;
                    this.oz = (Math.random()-0.5) * CONFIG.snowRange;
                    this.vy = Math.random() * 3 + 1.0; // 下落速度
                    this.sizeBase = Math.random() * 2 + 0.5; // 随机尺寸

                    // 雪花配色概率分布：60%白, 25%粉, 15%金
                    let r = Math.random();
                    if(r < 0.6) this.color = '255, 255, 255'; 
                    else if (r < 0.85) this.color = '255, 192, 203';
                    else this.color = '255, 223, 0';
                }
            }

            // 更新雪花物理状态
            updateSnow() {
                this.oy += this.vy; // 下落
                const lim = CONFIG.snowRange/2;
                if(this.oy > lim) this.oy = -lim; // 边界循环
                // 飘动效果：基于时间和相位的正弦波动
                let sway = Math.sin(state.time * 0.5 + this.phase) * 15;
                this._dx = this.ox + sway; // 计算显示位置
            }
        }

        // -----------------------
        // 场景构建函数
        // -----------------------
        function initScene() {
            particles = []; // 清空粒子数组
            const H = 580;       // 树的总高度
            const Y_TOP = -300;  // 树顶Y坐标
            const MAX_R = 290;   // 树底最大半径

            // 1. [树芯填充] - 创建内部填充粒子，保证树体饱满
            for(let i=0; i<CONFIG.fillParticles; i++) {
                let p = Math.random(); // 0-1的随机值
                // 内部圆锥形状：半径随高度增加
                let rMax = p * MAX_R * 0.6; 
                let r = Math.sqrt(Math.random()) * rMax; // 平方根分布，使粒子更靠近中心
                let a = Math.random() * Math.PI * 2; // 随机角度
                particles.push(new Particle({
                    x: Math.cos(a)*r, y: Y_TOP + p*H, z: Math.sin(a)*r,
                    type: 'inner', 
                    size: Math.random()*2 + 1,
                    // 内部颜色：深粉红为主，制造阴影层次感
                    color: Math.random()>0.5 ? COLORS.treeDeep : COLORS.treePink,
                    alpha: 0.7
                }));
            }

            // 2. [层级枝叶] - 创建9层树结构
            const LAYERS = CONFIG.treeLayers;
            for(let i=0; i<LAYERS; i++) {
                let p = i / (LAYERS - 1); // 当前层在总层数中的比例（0到1）
                let layerY = Y_TOP + p * H; // 当前层Y坐标
                
                // 半径曲线：上窄下宽，使用幂函数平滑过渡
                let layerMaxR = Math.pow(p, 0.9) * MAX_R + 20;

                // 每层的枝条数：顶部少，底部多
                let branches = 15 + Math.floor(p * 25); 

                // 为每个枝条创建粒子
                for(let b=0; b<branches; b++) {
                    let angleBase = (Math.PI*2/branches) * b; // 基础角度
                    // 层间错位：每层旋转一定角度，避免对齐
                    angleBase += i * 0.5;

                    // 每个枝条上的粒子数（决定蓬松度）
                    let ptrsInBranch = 30 + Math.floor(p * 20); 

                    // 在枝条上分布粒子
                    for(let k=0; k<ptrsInBranch; k++) {
                        let t = k / (ptrsInBranch-1); // 粒子在枝条上的位置（0根部到1尖端）
                        
                        let r = t * layerMaxR; // 当前粒子半径
                        
                        // 下垂感：尖端下垂更多，底层下垂更明显
                        let drop = Math.pow(t, 2) * (30 + p * 60);
                        
                        // 随机散布：制造毛茸茸的效果
                        let spread = (Math.random() - 0.5) * (5 + t * 25);

                        // 计算粒子3D坐标
                        let px = Math.cos(angleBase) * r + spread;
                        let pz = Math.sin(angleBase) * r + spread;
                        let py = layerY + drop + spread * 0.6;

                        // 颜色梯度：根据位置设置不同颜色
                        let c = COLORS.treePink; // 默认粉色
                        if(t > 0.9) c = COLORS.treeWhite; // 尖端积雪效果
                        else if(t < 0.3) c = COLORS.treeDeep; // 根部深红色
                        else if(Math.random()>0.8) c = COLORS.treePale; // 随机浅粉色点缀

                        particles.push(new Particle({
                            x: px, y: py, z: pz,
                            type: 'branch', size: Math.random()*2+1.2,
                            color: c
                        }));
                    }
                }
            }

            // 3. [螺旋光带] - 围绕树的装饰光带
            const SPIRAL_PTS = 800;
            for(let i=0; i<SPIRAL_PTS; i++) {
                let p = i/SPIRAL_PTS; // 在螺旋上的位置比例
                let ang = p * 35; // 旋转角度（绕树35圈）
                let r = Math.pow(p, 0.9) * MAX_R + 20; // 半径（悬浮在树表面外）

                // 颜色选择：白色为主，20%概率为浅粉色
                let isPink = Math.random() > 0.8; 
                let col = isPink ? '255, 192, 203' : '255, 255, 255';
                
                particles.push(new Particle({
                    x: Math.cos(ang)*r,
                    y: Y_TOP + p*H + Math.sin(ang)*15, // Y坐标加上正弦波动
                    z: Math.sin(ang)*r,
                    type: 'spiral',
                    size: 2.8,
                    color: col,
                    alpha: 1
                }));
            }

            // 4. [心形顶] - 树顶心形装饰
            createHeart(0, Y_TOP - 20, 0);

            // 5. [地板光晕] - 底部光环效果
            createFloor(320);

            // 6. [暴风雪] - 创建雪花粒子
            for(let i=0; i<CONFIG.snowCount; i++) {
                particles.push(new Particle({type: 'snow'}));
            }
        }

        // 创建心形函数
        function createHeart(cx, cy, cz) {
            // 使用参数方程创建心形
            for(let i=0; i<400; i++) {
                let t = Math.random() * Math.PI * 2; // 随机角度
                // 心形参数方程
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = -(13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t));
                let z = (Math.random()-0.5) * 8 * (1 - Math.abs(x)/20); // Z轴随机偏移
                
                particles.push(new Particle({
                    x: x*2.8, y: y*2.8 + cy, z: z*2.8, // 缩放并定位
                    type: 'heart', color: '255, 20, 80', size: 2.2
                }));
            }
            // 心形中心高光
            particles.push(new Particle({
                x:0, y:cy, z:0, type:'heart', size:12, 
                color:'255,255,255', alpha:0.5
            }));
        }

        // 创建地板光晕函数
        function createFloor(y) {
            // 从内到外创建多个同心圆环
            for(let r=60; r<600; r+=20) {
                let cnt = r; // 每个环的粒子数随半径增加
                for(let j=0; j<cnt; j++) {
                    let ang = (j/cnt)*Math.PI*2 + Math.random(); // 随机角度偏移
                    particles.push(new Particle({
                        x: Math.cos(ang)*(r+Math.random()*15), // 半径随机变化
                        y: y + Math.sin(ang*6)*3, // Y坐标正弦波动
                        z: Math.sin(ang)*(r+Math.random()*15),
                        type: 'floor', color: '200, 220, 255', // 淡蓝色
                        size: Math.random()>0.9?1.8:0.8, alpha:0.4 // 大小随机，半透明
                    }));
                }
            }
        }

        // -----------------------
        // 渲染主循环
        // -----------------------
        function loop() {
            // 设置画布尺寸为窗口大小
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            let cx = width/2; // 画布中心X
            let cy = height/2; // 画布中心Y

            // 清空画布为黑色背景
            ctx.fillStyle = "#000000"; 
            ctx.fillRect(0,0,width,height);

            // 更新全局时间
            state.time += 0.01;
            state.autoRot += 0.003; // 自动旋转

            // 预计算三角函数值（优化性能）
            let sinA=Math.sin(state.autoRot), cosA=Math.cos(state.autoRot);
            let sinX=Math.sin(state.rotX), cosX=Math.cos(state.rotX);
            let sinY=Math.sin(state.rotY), cosY=Math.cos(state.rotY);

            let drawArr = []; // 待绘制粒子数组

            // 批量处理所有粒子
            for(let i=0; i<particles.length; i++) {
                let p = particles[i];
                let px, py, pz;

                // 根据粒子类型计算位置
                if(p.type === 'snow') {
                    p.updateSnow(); // 更新雪花位置
                    // 雪花不受树木自转影响
                    px = p._dx; 
                    py = p.oy;
                    pz = p.oz; 
                } else {
                    // 树木部件参与自转
                    px = p.ox*cosA - p.oz*sinA; // X轴旋转
                    py = p.oy;
                    pz = p.oz*cosA + p.ox*sinA; // Z轴旋转
                }

                // 相机视角变换（世界空间到相机空间）
                // X轴旋转（俯仰角）
                let y2 = py*cosX - pz*sinX;
                let z2 = pz*cosX + py*sinX;
                // Y轴旋转（偏航角）
                let x3 = px*cosY - z2*sinY;
                let z3 = z2*cosY + px*sinY;
                
                // 透视投影计算
                let fov = CONFIG.baseDist * state.zoom; // 视场距离
                let scale = fov / (fov + z3); // 透视缩放系数

                // 只绘制在视野内的粒子
                if(scale > 0) {
                    p._sx = cx + x3 * scale; // 屏幕X坐标
                    p._sy = cy + y2 * scale; // 屏幕Y坐标
                    p._ss = scale; // 缩放比例
                    p._sz = z3; // Z深度（用于排序）
                    drawArr.push(p);
                }
            }

            // Z排序：从远到近绘制，避免透视错误
            drawArr.sort((a,b) => b._sz - a._sz);

            // 设置混合模式为光效叠加
            ctx.globalCompositeOperation = 'lighter';

            // 绘制所有粒子
            for(let p of drawArr) {
                // 计算透明度和尺寸
                let alpha = p.alphaBase;
                let size = p.sizeBase * p._ss;

                // 距离雾化效果：远处粒子逐渐消失
                if(p._sz > 1000) {
                    alpha *= (1 - (p._sz-1000)/2000);
                    if(alpha<=0) continue; // 完全透明则跳过绘制
                }

                // 闪烁效果处理
                p.phase += 0.05;
                if(p.type !== 'snow') {
                    // 树木部件快速闪烁
                    alpha *= (0.7 + 0.3 * Math.sin(p.phase));
                } else {
                    // 雪花近处模糊效果
                    if (size > 3) alpha *= 0.6; 
                }

                // 绘制粒子圆形
                ctx.beginPath();
                ctx.fillStyle = `rgba(${p.color}, ${alpha})`;
                ctx.arc(p._sx, p._sy, size, 0, Math.PI*2);
                ctx.fill();
                
                // 特殊粒子的光晕效果
                if((p.type === 'heart' || p.type === 'spiral') || (p.type==='snow' && size>2.5)) {
                    ctx.beginPath();
                    ctx.fillStyle = `rgba(${p.color}, ${alpha * 0.2})`; // 更透明的光晕
                    ctx.arc(p._sx, p._sy, size*2.5, 0, Math.PI*2); // 更大的光晕半径
                    ctx.fill();
                }
            }

            // 恢复默认混合模式
            ctx.globalCompositeOperation = 'source-over';
            // 请求下一帧动画
            requestAnimationFrame(loop);
        }

        // -----------------------
        // 交互监听
        // -----------------------
        let isDrag=false, lx=0, ly=0; // 拖拽状态和上次位置
        
        // 视角移动函数
        function moveView(dx, dy) {
            state.rotY += dx * 0.005; // Y轴旋转（水平拖拽）
            state.rotX += dy * 0.005; // X轴旋转（垂直拖拽）
        }

        // 鼠标事件监听
        window.addEventListener('mousedown', e => {
            isDrag=true; 
            lx=e.clientX; // 记录起始X
            ly=e.clientY; // 记录起始Y
        });
        window.addEventListener('mouseup', () => isDrag=false); // 停止拖拽
        window.addEventListener('mousemove', e => {
            if(!isDrag) return;
            moveView(e.clientX-lx, e.clientY-ly); // 计算移动距离
            lx=e.clientX; // 更新位置
            ly=e.clientY;
        });

        // 触屏事件监听（移动端）
        window.addEventListener('touchstart', e => {
            isDrag=true; 
            lx=e.touches[0].clientX; 
            ly=e.touches[0].clientY;
        }, {passive:false});
        window.addEventListener('touchend', () => isDrag=false);
        window.addEventListener('touchmove', e => {
            if(!isDrag) return;
            e.preventDefault(); // 阻止默认滚动行为
            moveView(e.touches[0].clientX-lx, e.touches[0].clientY-ly);
            lx=e.touches[0].clientX; 
            ly=e.touches[0].clientY;
        }, {passive:false});

        // 滚轮缩放事件
        window.addEventListener('wheel', e => {
            state.zoom -= Math.sign(e.deltaY) * 0.05; // 根据滚轮方向缩放
            if(state.zoom < 0.2) state.zoom=0.2; // 最小缩放限制
            if(state.zoom > 3) state.zoom=3; // 最大缩放限制
        }, {passive:false});

        // 窗口大小变化事件
        window.addEventListener('resize', ()=> { 
            width=canvas.width; 
            height=canvas.height; 
        });

        // 初始化场景并开始动画循环
        initScene();
        loop();

    </script>
</body>
</html>
